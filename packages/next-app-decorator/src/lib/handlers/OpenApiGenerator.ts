import { ApiReference } from "@scalar/nextjs-api-reference";
import {
  OpenApiBuilder,
  OperationObject,
  ParameterObject,
  PathItemObject,
  ResponsesObject,
  SchemaObject,
  TagObject,
} from "openapi3-ts/oas30";
import { z } from "zod";
import { AppRoute, SwaggerConfig } from "../types";
import { deepMergeObjects, zodToOpenAPI } from "../utils";
import { RouterFactory } from "./RouterFactory";
import { Metadata } from "../metadata";
import { HttpStatusCode } from "../http-status";

export class OpenAPIFactory {
  private builder: OpenApiBuilder;

  constructor(
    private routes: AppRoute,
    private config: SwaggerConfig
  ) {
    this.builder = new OpenApiBuilder();
    this.config = {
      ...config,
      openapi: "3.0.0",
      info: {
        title: config.info?.title ?? "API Documentation",
        version: config.info?.version ?? "1.0.0",
        description:
          config.info?.description ??
          "API documentation generated by Next Router Decorator",
      },
    };
  }

  private addBasicInfo(): OpenAPIFactory {
    this.builder.addInfo(this.config.info!);
    return this;
  }

  private addServers(): OpenAPIFactory {
    if (this.config.servers) {
      this.config.servers.forEach((server) => {
        this.builder.addServer(server);
      });
    } else {
      this.builder.addServer({
        url: "http://localhost:3000",
        description: "Local server",
      });
    }
    return this;
  }

  private addTags(): OpenAPIFactory {
    this.config.tags?.forEach((tag) => this.builder.addTag(tag));
    return this;
  }

  private addSecurityDefinitions(): OpenAPIFactory {
    if (this.config.security) {
      Object.entries(this.config.security).forEach(([name, scheme]) => {
        this.builder.addSecurityScheme(name, scheme as any);
      });
    }
    return this;
  }

  private processRoutes(): OpenAPIFactory {
    const tags = new Set<TagObject>();

    Object.entries(this.routes).forEach(([path, methods]) => {
      const pathItem: PathItemObject = {};

      Object.entries(methods).forEach(([method, routeConfig]) => {
        const operation: OperationObject = {
          parameters: [],
          responses: this.addInternalServerErrorResponse(),
        };

        const [_, tagInfo] = Metadata.get("prefix", routeConfig.target) ?? [];
        if (tagInfo) {
          tags.add(tagInfo);
        }

        const className = (routeConfig.target as Function).name;
        const methodName = String(routeConfig.methodName);
        operation.summary =
          routeConfig.hook.info?.summary ??
          `${method} ${className} ${methodName}`;

        operation.description =
          routeConfig.hook.info?.description ??
          `${method} ${className} ${methodName}`;
        operation.operationId =
          routeConfig.hook.info?.id ?? `${className}_${methodName}`;
        operation.tags = routeConfig.hook.info?.tags ?? [
          tagInfo?.name ?? className,
        ];
        operation.deprecated = routeConfig.hook.info?.deprecated ?? false;

        const parameters = [] as ParameterObject[];
        if (routeConfig.hook?.path) {
          const pathParams = routeConfig.hook.path._def.shape() as Record<
            string,
            any
          >;
          Object.entries(pathParams).forEach(([key, value]) => {
            parameters.push({
              name: key,
              in: "path",
              required: value instanceof z.ZodOptional ? false : true,
              schema: zodToOpenAPI(value),
            });
          });

          operation.responses = this.addBadRequestResponse(operation.responses);
        } else if (path.includes(":")) {
          const pathParams = path.match(/:([^/]+)/g);
          pathParams?.forEach((param) => {
            parameters.push({
              name: param.slice(1),
              in: "path",
              required: true,
              schema: { type: "string" },
            });
          });
        }

        if (routeConfig.hook.query) {
          const queryParams = routeConfig.hook.query._def.shape() as Record<
            string,
            any
          >;
          Object.entries(queryParams).forEach(([key, value]) => {
            parameters.push({
              name: key,
              in: "query",
              required: value instanceof z.ZodOptional ? false : true,
              schema: zodToOpenAPI(value),
            });
          });
          operation.responses = this.addBadRequestResponse(operation.responses);
        }

        if (parameters.length > 0) {
          operation.parameters = parameters;
        }

        if (routeConfig.hook.body) {
          operation.requestBody = {
            content: {
              "application/json": {
                schema: zodToOpenAPI(routeConfig.hook.body),
              },
            },
          };
          operation.responses = this.addBadRequestResponse(operation.responses);
        } else if (routeConfig.hook.formData) {
          operation.requestBody = {
            content: {
              "multipart/form-data": {
                schema: zodToOpenAPI(routeConfig.hook.formData),
              },
            },
          };
          operation.responses = this.addBadRequestResponse(operation.responses);
        }

        if (routeConfig.hook.response) {
          if (Object.hasOwn(routeConfig.hook.response, "_def")) {
            const statusCode: number =
              Metadata.get(
                "statusCode",
                routeConfig.target,
                routeConfig.methodName
              ) ??
              routeConfig.hook.status ??
              HttpStatusCode.Ok;

            operation.responses = deepMergeObjects(operation.responses ?? {}, {
              [statusCode]: {
                description: "Successful response",
                content: {
                  "application/json": {
                    schema: this.responseOpenAPI(
                      zodToOpenAPI(routeConfig.hook.response as z.ZodTypeAny)
                    ),
                  },
                },
              },
            });
          } else if (Object.values(routeConfig.hook?.response)?.at(0)?._def) {
            operation.responses = deepMergeObjects(
              operation.responses,
              Object.entries(routeConfig.hook.response).reduce(
                (acc, [statusCode, schema]) => {
                  acc[statusCode] = {
                    description: HttpStatusCode[Number(statusCode)]
                      ? HttpStatusCode[Number(statusCode)]
                          .replace(/([A-Z])/g, " $1")
                          .trim()
                      : "Successful response",
                    content: {
                      "application/json": {
                        schema: this.responseOpenAPI(zodToOpenAPI(schema)),
                      },
                    },
                  };
                  return acc;
                },
                {} as Record<string, any>
              )
            );
          } else if (
            Object.values(routeConfig.hook?.response)?.at(0) instanceof Object
          ) {
            operation.responses = deepMergeObjects(
              operation.responses,
              Object.entries(routeConfig.hook.response).reduce(
                (acc, [statusCode, { description, schema, content }]) => {
                  acc[statusCode] = schema
                    ? {
                        description,
                        content: {
                          "application/json": {
                            schema: this.responseOpenAPI(zodToOpenAPI(schema)),
                          },
                        },
                      }
                    : content && {
                        description,
                        content: Object.entries(content).reduce(
                          // @ts-expect-error type schema hack
                          (acc, [contentType, { schema, example }]) => {
                            acc[contentType] = {
                              schema: this.responseOpenAPI(
                                zodToOpenAPI(schema)
                              ),
                              example,
                            };
                            return acc;
                          },
                          {}
                        ),
                      };
                  return acc;
                },
                {} as Record<string, any>
              )
            );
          }
        }

        // Security
        if (routeConfig.hook.security) {
          operation.security = Object.entries(routeConfig.hook.security).map(
            ([name, scopes]) => ({
              [name]: scopes,
            })
          );
        }

        pathItem[method.toLowerCase() as keyof PathItemObject] = operation;
      });

      const openApiPath = path.replace(/:(\w+)/g, "{$1}");

      this.builder.addPath(openApiPath, pathItem);
    });

    tags.forEach((tag) => this.builder.addTag(tag));

    return this;
  }

  private setupDefaultErrorResponse() {
    const ErrorDetailSchema = z.object({
      code: z.string(),
      expected: z.string().optional(),
      received: z.string().optional(),
      path: z.array(z.string()).optional(),
      message: z.string().optional(),
    });

    const BadRequestSchema = z.object({
      error: z.array(ErrorDetailSchema),
    });

    let response = {
      description: "Bad Request",
      content: {
        "application/json": {
          schema: zodToOpenAPI(BadRequestSchema),
        },
      },
    };

    this.builder.addResponse("BadRequest", response);

    response = {
      description: "Internal Server Error",
      content: {
        "application/json": {
          schema: this.responseOpenAPI(
            zodToOpenAPI(z.object({ error: z.string() }))
          ),
        },
      },
    };

    this.builder.addResponse("InternalServerError", response);

    return this;
  }

  private addBadRequestResponse(
    responses: ResponsesObject = {}
  ): ResponsesObject {
    return deepMergeObjects(responses ?? {}, {
      [HttpStatusCode.BadRequest]: {
        $ref: "#/components/responses/BadRequest",
      },
    });
  }

  private addInternalServerErrorResponse(
    responses: ResponsesObject = {}
  ): ResponsesObject {
    return deepMergeObjects(responses ?? {}, {
      [HttpStatusCode.InternalServerError]: {
        $ref: "#/components/responses/InternalServerError",
      },
    });
  }

  private responseOpenAPI<T extends SchemaObject>(schema: T): T {
    const newSchema = { ...schema };
    function processSchema(obj) {
      if (obj.hasOwnProperty("required")) {
        delete obj.required;
      }

      if (obj.properties && typeof obj.properties === "object") {
        Object.values(obj.properties).forEach((prop) => {
          processSchema(prop);
        });
      }

      if (obj.items && typeof obj.items === "object") {
        processSchema(obj.items);
      }

      if (
        obj.additionalProperties &&
        typeof obj.additionalProperties === "object"
      ) {
        processSchema(obj.additionalProperties);
      }
    }

    processSchema(newSchema);
    return newSchema;
  }

  public build(): OpenAPIFactory {
    return this.addBasicInfo()
      .addServers()
      .addTags()
      .addSecurityDefinitions()
      .setupDefaultErrorResponse()
      .processRoutes();
  }

  public getSpec() {
    return this.builder.getSpec();
  }

  // Static factory method
  public static create(routeFactory: RouterFactory, config: SwaggerConfig) {
    const content = new OpenAPIFactory(routeFactory.routes, config)
      .build()
      .getSpec();

    routeFactory.routes = deepMergeObjects(routeFactory.routes, {
      [config.path]: {
        GET: {
          handler: ApiReference({
            content,
          }),
        },
      },
    } as AppRoute);
  }
}
